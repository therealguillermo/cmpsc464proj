"""
Membership Tester Module

This module checks if a string can be generated by a CNF grammar.

Key Idea: For CNF grammars, if a string has length n, then any derivation
         of that string takes exactly 2n - 1 steps.

Example: To derive "ab" (length 2), we need exactly 2*2 - 1 = 3 steps.

We use a "brute force" approach: try all possible ways to derive the string
by trying all possible rule applications and string splits.
"""

from grammar_parser import Grammar


class MembershipTester:
    """
    Tests if strings belong to a CNF grammar.
    
    Uses a naive brute force algorithm that tries all possible derivations.
    This can be slow for long strings, but it's guaranteed to find the answer
    if the string can be generated.
    """
    
    def __init__(self, grammar: Grammar):
        """
        Create a membership tester for a grammar.
        
        Args:
            grammar: The CNF grammar to test strings against
        """
        self.grammar = grammar
        # Cache to avoid recalculating the same thing multiple times
        # Key: (variable, string, steps_remaining) -> True/False
        self.cache = {}
    
    def test_membership(self, string: str) -> bool:
        """
        Test if a string belongs to the grammar.
        
        Args:
            string: The string to test (use '' for empty string/epsilon)
        
        Returns:
            True if the string can be generated, False otherwise
        
        Example:
            tester = MembershipTester(grammar)
            if tester.test_membership("ab"):
                print("Yes, 'ab' can be generated!")
        """
        # Special case: empty string (epsilon)
        if string == '':
            return self._can_derive_epsilon('S')
        
        # For a string of length n, we need exactly 2n - 1 steps
        string_length = len(string)
        required_steps = 2 * string_length - 1
        
        # Clear cache for new test
        self.cache.clear()
        
        # Try to derive the string starting from S
        return self._try_to_derive('S', string, required_steps)
    
    def _can_derive_epsilon(self, variable: str) -> bool:
        """
        Check if a variable can produce epsilon (empty string).
        
        Args:
            variable: The variable to check (like 'S' or 'A')
        
        Returns:
            True if this variable has a rule like A -> $, False otherwise
        """
        if variable not in self.grammar.rules:
            return False
        
        # Look for a production that is just epsilon ($)
        for production in self.grammar.rules[variable]:
            if len(production) == 1 and production[0] == '$':
                return True
        
        return False
    
    def _try_to_derive(self, variable: str, target_string: str, steps_remaining: int) -> bool:
        """
        Try to derive target_string from variable using at most steps_remaining steps.
        
        This is the main recursive function. It tries all possible ways to derive
        the target string.
        
        Args:
            variable: The variable we're trying to derive from (like 'S')
            target_string: The string we want to produce (like "ab")
            steps_remaining: How many steps we have left
        
        Returns:
            True if we can derive target_string, False otherwise
        """
        # Check cache first - have we seen this before?
        cache_key = (variable, target_string, steps_remaining)
        if cache_key in self.cache:
            return self.cache[cache_key]
        
        # Base case 1: No steps left - can only succeed if variable equals string
        if steps_remaining == 0:
            result = (variable == target_string)
            self.cache[cache_key] = result
            return result
        
        # Base case 2: Empty string - check if variable can produce epsilon
        if len(target_string) == 0:
            result = self._can_derive_epsilon(variable)
            self.cache[cache_key] = result
            return result
        
        # Base case 3: Single character - check if variable has terminal rule
        if len(target_string) == 1:
            if variable not in self.grammar.rules:
                self.cache[cache_key] = False
                return False
            
            # Look for a rule like A -> 'a' that matches our character
            for production in self.grammar.rules[variable]:
                if len(production) == 1 and production[0] == target_string:
                    # Found matching terminal rule - need exactly 1 step
                    if steps_remaining == 1:
                        self.cache[cache_key] = True
                        return True
                    # Can't use more than 1 step for a single terminal
                    continue
            
            self.cache[cache_key] = False
            return False
        
        # Recursive case: Try binary rules (like S -> AB)
        if variable not in self.grammar.rules:
            self.cache[cache_key] = False
            return False
        
        # Try each production rule for this variable
        for production in self.grammar.rules[variable]:
            # Only binary rules (2 symbols) can help us derive longer strings
            if len(production) == 2:
                left_variable = production[0]  # First variable (like A in S -> AB)
                right_variable = production[1]  # Second variable (like B in S -> AB)
                
                # Try splitting the target string in all possible ways
                # Example: "abc" can be split as "a"+"bc" or "ab"+"c"
                for split_point in range(1, len(target_string)):
                    left_part = target_string[:split_point]   # First part
                    right_part = target_string[split_point:]  # Second part
                    
                    # Calculate how many steps each part needs
                    left_steps = self._calculate_steps_needed(left_variable, left_part)
                    right_steps = self._calculate_steps_needed(right_variable, right_part)
                    
                    # If either part is impossible, skip this split
                    if left_steps < 0 or right_steps < 0:
                        continue
                    
                    # Total steps = 1 (for this binary rule) + steps for left + steps for right
                    total_steps_needed = 1 + left_steps + right_steps
                    
                    # Check if we have enough steps
                    if total_steps_needed > steps_remaining:
                        continue
                    
                    # Try to derive left part from left variable, right part from right variable
                    if (self._try_to_derive(left_variable, left_part, left_steps) and
                        self._try_to_derive(right_variable, right_part, right_steps)):
                        # Success! We found a way to derive the string
                        self.cache[cache_key] = True
                        return True
        
        # If we get here, we couldn't derive the string
        self.cache[cache_key] = False
        return False
    
    def _calculate_steps_needed(self, variable: str, string_part: str) -> int:
        """
        Calculate how many steps are needed to derive string_part from variable.
        
        For CNF:
        - String of length k needs 2k - 1 steps
        - Empty string (epsilon) needs 1 step if variable can produce epsilon
        
        Args:
            variable: The variable we're deriving from
            string_part: The string we want to produce
        
        Returns:
            Number of steps needed, or -1 if impossible
        """
        if len(string_part) == 0:
            # Empty string - need 1 step if variable can produce epsilon
            if self._can_derive_epsilon(variable):
                return 1
            else:
                return -1  # Impossible
        else:
            # For string of length k, need 2k - 1 steps
            return 2 * len(string_part) - 1


def test_membership(grammar: Grammar, string: str) -> bool:
    """
    Convenience function to test if a string belongs to a grammar.
    
    This is a simpler way to test membership without creating a MembershipTester object.
    
    Args:
        grammar: The CNF grammar
        string: The string to test
    
    Returns:
        True if string belongs to grammar, False otherwise
    
    Example:
        grammar = parse_grammar_file("grammar.txt")
        if test_membership(grammar, "ab"):
            print("Yes!")
    """
    tester = MembershipTester(grammar)
    return tester.test_membership(string)
